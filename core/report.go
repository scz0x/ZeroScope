package core

import (
	"encoding/json"
	"fmt"
	"os"
	"path/filepath"
	"strings"

	"github.com/jung-kurt/gofpdf"
)

type Report struct {
	FileCounts   map[string]int     `json:"file_counts"`
	SizesMB      map[string]float64 `json:"sizes_mb"`
	Suspicious   []string           `json:"suspicious_so"`
	Permissions  []string           `json:"permissions"`
	Dangerous    []string           `json:"dangerous_permissions"`
	SecretsFound []string           `json:"secrets_found"`
}

func IsDangerous(p string) bool {
	dangerousPermissions := []string{
		"android.permission.READ_SMS",
		"android.permission.SYSTEM_ALERT_WINDOW",
		"android.permission.REQUEST_INSTALL_PACKAGES",
		"android.permission.CALL_PHONE",
		"android.permission.RECORD_AUDIO",
		"android.permission.READ_CONTACTS",
		"android.permission.WRITE_EXTERNAL_STORAGE",
		"android.permission.READ_PHONE_STATE",
	}
	for _, d := range dangerousPermissions {
		if strings.EqualFold(p, d) {
			return true
		}
	}
	return false
}

func GenerateReportJSON(outputDir string, r Report) {
	os.MkdirAll(outputDir, 0755)
	path := filepath.Join(outputDir, "report.json")
	f, err := os.Create(path)
	if err != nil {
		fmt.Println("[‚úó] Failed to write JSON:", err)
		return
	}
	defer f.Close()
	json.NewEncoder(f).Encode(r)
	fmt.Println("[‚úì] report.json generated at", path)
}

func GenerateHTMLReport(outputDir string, r Report) {
	os.MkdirAll(outputDir, 0755)
	out, err := os.Create(filepath.Join(outputDir, "report.html"))
	if err != nil {
		fmt.Println("[‚úó] Failed to write HTML:", err)
		return
	}
	defer out.Close()

	var dangerCount int
	for _, p := range r.Permissions {
		if IsDangerous(p) {
			dangerCount++
		}
	}

	html := `<!DOCTYPE html><html><head><meta charset="UTF-8"><title>ZeroScope Report</title>
<style>
body{background:#0e0e0e;color:#eee;font-family:Arial;padding:20px}
h1{color:#33ccff}.danger{color:#ff5050}
table{width:100%%;border-collapse:collapse;margin-top:16px}
th,td{border:1px solid #444;padding:8px}
th{background:#222}tr:nth-child(even){background:#1a1a1a}
img.logo{width:140px;margin-bottom:10px;border-radius:8px}
</style></head><body>
<img src="/logo.png" alt="logo" class="logo">
<h1>üìä ZeroScope HTML Report</h1>
<table><tr><th>Type</th><th>Count</th><th>Size (MB)</th></tr>`
	for k, v := range r.FileCounts {
		html += fmt.Sprintf("<tr><td>%s</td><td>%d</td><td>%.2f</td></tr>", k, v, r.SizesMB[k])
	}
	html += `</table><h2>‚ö†Ô∏è Suspicious .so Files</h2><ul>`
	for _, f := range r.Suspicious {
		html += fmt.Sprintf("<li class='danger'>%s</li>", f)
	}
	html += `</ul><h2>üîê Permissions</h2><ul>`
	for _, p := range r.Permissions {
		class := ""
		if IsDangerous(p) {
			class = "class='danger'"
		}
		html += fmt.Sprintf("<li %s>%s</li>", class, p)
	}
	html += `</ul><h2>üß¨ Sensitive Strings</h2><ul>`
	for _, s := range r.SecretsFound {
		trimmed := s
		if len(s) > 100 {
			trimmed = s[:100] + "..."
		}
		if strings.Contains(strings.ToLower(s), "key") || strings.Contains(strings.ToLower(s), "token") {
			html += fmt.Sprintf("<li class='danger'>%s</li>", trimmed)
		} else {
			html += fmt.Sprintf("<li>%s</li>", trimmed)
		}
	}
	html += fmt.Sprintf(`</ul><h2>üì¶ Summary</h2><ul>
<li>Detected types: %d</li>
<li>Dangerous permissions: %d</li>
<li>Sensitive strings: %d</li>
</ul><hr><p>üéØ Generated by <strong>ZeroScope</strong> ‚Äî developed by scz0x<br>üì° Channel: <a href="https://t.me/SCZ0X_CH">t.me/SCZ0X_CH</a></p></body></html>`,
		len(r.FileCounts), dangerCount, len(r.SecretsFound),
	)

	out.WriteString(html)
	fmt.Println("[‚úì] report.html generated at", filepath.Join(outputDir, "report.html"))
}


func GeneratePDFReport(outputDir string, r Report) {
	os.MkdirAll(outputDir, 0755)
	pdf := gofpdf.New("P", "mm", "A4", "")
	pdf.SetTitle("ZeroScope Report", false)
	pdf.AddPage()
	pdf.SetFont("Arial", "B", 16)
	pdf.Cell(0, 10, "ZeroScope Report")
	pdf.Ln(12)

	pdf.SetFont("Arial", "", 12)
	pdf.Cell(0, 8, "File Summary:")
	pdf.Ln(8)
	for k, v := range r.FileCounts {
		line := fmt.Sprintf("- %s: %d file(s), %.2f MB", k, v, r.SizesMB[k])
		pdf.Cell(0, 7, line)
		pdf.Ln(6)
	}

	if len(r.Suspicious) > 0 {
		pdf.Ln(6)
		pdf.Cell(0, 8, "Suspicious .so Files:")
		pdf.Ln(8)
		for _, f := range r.Suspicious {
			pdf.Cell(0, 6, "‚Ä¢ "+f)
			pdf.Ln(6)
		}
	}

	if len(r.Permissions) > 0 {
		pdf.Ln(6)
		pdf.Cell(0, 8, "Permissions:")
		pdf.Ln(8)
		for _, p := range r.Permissions {
			label := "  " + p
			if IsDangerous(p) {
				label = "‚ö†Ô∏è " + p
			}
			pdf.Cell(0, 6, label)
			pdf.Ln(6)
		}
	}

	if len(r.SecretsFound) > 0 {
		pdf.Ln(6)
		pdf.Cell(0, 8, "Sensitive Strings:")
		pdf.Ln(8)
		pdf.SetFont("Courier", "", 9)
		for _, s := range r.SecretsFound {
			trimmed := s
			if len(s) > 100 {
				trimmed = s[:100] + "..."
			}
			pdf.MultiCell(190, 5, trimmed, "", "", false)
		}
		pdf.SetFont("Arial", "", 12)
	}

	pdf.Ln(10)
	pdf.SetFont("Arial", "I", 10)
	pdf.Cell(0, 10, "üéØ Report by ZeroScope ‚Äî developed by scz0x")
	pdf.Ln(5)
	pdf.Cell(0, 10, "üì° Channel: https://t.me/SCZ0X_CH")

	outPath := filepath.Join(outputDir, "report.pdf")
	if err := pdf.OutputFileAndClose(outPath); err != nil {
		fmt.Println("[‚úó] Failed to write PDF:", err)
	} else {
		fmt.Println("[‚úì] report.pdf generated at", outPath)
	}
}